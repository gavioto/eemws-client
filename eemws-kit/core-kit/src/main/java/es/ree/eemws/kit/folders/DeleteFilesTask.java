/*
 * Copyright 2014 Red Eléctrica de España, S.A.U.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation, version 3 of the license.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTIBIILTY or FITNESS FOR A PARTICULAR PURPOSE. See GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program. If not, see
 * http://www.gnu.org/licenses/.
 *
 * Any redistribution and/or modification of this program has to make
 * reference to Red Eléctrica de España, S.A.U. as the copyright owner of
 * the program.
 */

package es.ree.eemws.kit.folders;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import es.ree.eemws.kit.common.Messages;
import es.ree.eemws.core.utils.file.FileUtil;

/**
 * Removes all the files with modification timestamp older than the time specified.
 * @author Red Eléctrica de España, S.A.U.
 * @version 1.0 29/05/2014
 * 
 */
public final class DeleteFilesTask implements Runnable {

	/** Backup folder. */
	private String backupFolder;

	/** Folders to be deleted. */
	private List<File> folders = new ArrayList<>();

	/** Object for message checking generated by other node. */
	private LockHandler lh;

	/** Number of days during a generated file will exist. */
	private int numberOfDays;

	/** Thread log system. */
	private static final Logger LOGGER = Logger.getLogger(DeleteFilesTask.class.getName());

	/** 1MB Buffer. */
	private static final byte[] BUFFER = new byte[1024 * 1024];

	/** Nombre del fichero de backup. */
	private static final String BACKUP_FILE_NAME = "'backup_'ddMMyyyy'.zip'"; //$NON-NLS-1$

	/** Nombre del fichero backup termporal. */
	private static final String BACKUP_TEMPORARY_FILE = "/tmp.zip"; //$NON-NLS-1$

	/**
	 * Constructor.
	 * @param lockHandler Lock manager. Prevents multiple nodes from creating backup files at once.
	 * @param config Module settings.
	 */
	public DeleteFilesTask(final LockHandler lockHandler, final Configuration config) {

	    for (int k = 0; config.getOutputFolder(k) != null; k++) {
	        folders.add(new File(config.getOutputFolder(k)));
	    }
	     
	    for (int k = 0; config.getProcessedFolder(k) != null; k++) {
	        folders.add(new File(config.getProcessedFolder(k)));
	    }

	    for (int k = 0; config.getResponseFolder(k) != null; k++) {
	        folders.add(new File(config.getResponseFolder(k)));
	    }
	
		numberOfDays = config.getNumOfDaysKept();
		backupFolder = config.getBackupFolder();
		lh = lockHandler;
	}

	/**
	 * Delete files in specified folders which modification date is previous or equal to the deletion date.
	 */
	@Override
	public void run() {
		try {
			if (backupFolder != null) {

				Calendar cal = Calendar.getInstance();
				cal.add(Calendar.DATE, -numberOfDays);
				Long deleteDate = cal.getTimeInMillis();

				SimpleDateFormat sdf = new SimpleDateFormat(BACKUP_FILE_NAME);
				String bakZipName = sdf.format(new Date());

				if (lh.tryLock(bakZipName)) {

					/*
					 * If the temporary directory and the backup directory are in different filesystems, the "move"
					 * operation could fail. In this point we create a temporary file in the backup folder.
					 */
					File tmpZip = new File(backupFolder + BACKUP_TEMPORARY_FILE);

					try (ZipOutputStream zosTmp = new ZipOutputStream(new FileOutputStream(tmpZip));) {

						File backupZipFile = new File(backupFolder + File.separator + bakZipName);

						copyOldBackup(zosTmp, backupZipFile);

						for (File folder : folders) {

							File[] fileList = folder.listFiles();

							if (fileList != null) {

								for (File file : fileList) {

									if (file.lastModified() <= deleteDate) {
										zosTmp.putNextEntry(new ZipEntry(file.getName()));
										zosTmp.write(FileUtil.readBinary(file.getAbsolutePath()));
										zosTmp.closeEntry();

										boolean delete = file.delete();
										if (!delete) {
											LOGGER.warning(Messages.getString("MF_UNABLE_TO_DELETE", file.getAbsolutePath())); //$NON-NLS-1$
										}
									}
								}
							}
						}

					} catch (IOException e) {
						LOGGER.log(Level.SEVERE, Messages.getString("MF_UNABLE_TO_BACKUP"), e); //$NON-NLS-1$
					}
				}

				lh.releaseLock(bakZipName);
			}

		} catch (Exception ex) {

			// Defensive exception, if runnable task ends with exception won't be exectued againg!
			LOGGER.log(Level.SEVERE, Messages.getString("MF_UNEXPECTED_ERROR"), ex); //$NON-NLS-1$
		}
	}

	/**
	 * Copies an existent zip file into other.
	 * @param zosTmp New Zip file output stream.
	 * @param backupZipFile Old Zip file reference.
	 * @throws IOException If the application cannot write into the new Zip File.
	 */
	private void copyOldBackup(final ZipOutputStream zosTmp, final File backupZipFile) throws IOException {
		if (backupZipFile.exists()) {

			try (ZipFile oldZip = new ZipFile(backupZipFile)) {

				Enumeration<? extends ZipEntry> entries = oldZip.entries();

				while (entries.hasMoreElements()) {
					ZipEntry e = entries.nextElement();

					zosTmp.putNextEntry(e);
					if (!e.isDirectory()) {

						int bytesRead;
						while ((bytesRead = oldZip.getInputStream(e).read(BUFFER)) != -1) {
							zosTmp.write(BUFFER, 0, bytesRead);
						}

					}
					zosTmp.closeEntry();
				}
			}
		}
	}

}
